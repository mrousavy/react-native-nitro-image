///
/// JAsyncImageLoadOptions.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "AsyncImageLoadOptions.hpp"

#include "AsyncImagePriority.hpp"
#include "JAsyncImagePriority.hpp"
#include <optional>

namespace margelo::nitro::image {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "AsyncImageLoadOptions" and the the Kotlin data class "AsyncImageLoadOptions".
   */
  struct JAsyncImageLoadOptions final: public jni::JavaClass<JAsyncImageLoadOptions> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/image/AsyncImageLoadOptions;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct AsyncImageLoadOptions by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    AsyncImageLoadOptions toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldPriority = clazz->getField<JAsyncImagePriority>("priority");
      jni::local_ref<JAsyncImagePriority> priority = this->getFieldValue(fieldPriority);
      static const auto fieldForceRefresh = clazz->getField<jni::JBoolean>("forceRefresh");
      jni::local_ref<jni::JBoolean> forceRefresh = this->getFieldValue(fieldForceRefresh);
      static const auto fieldContinueInBackground = clazz->getField<jni::JBoolean>("continueInBackground");
      jni::local_ref<jni::JBoolean> continueInBackground = this->getFieldValue(fieldContinueInBackground);
      static const auto fieldAllowInvalidSSLCertificates = clazz->getField<jni::JBoolean>("allowInvalidSSLCertificates");
      jni::local_ref<jni::JBoolean> allowInvalidSSLCertificates = this->getFieldValue(fieldAllowInvalidSSLCertificates);
      static const auto fieldScaleDownLargeImages = clazz->getField<jni::JBoolean>("scaleDownLargeImages");
      jni::local_ref<jni::JBoolean> scaleDownLargeImages = this->getFieldValue(fieldScaleDownLargeImages);
      static const auto fieldQueryMemoryDataSync = clazz->getField<jni::JBoolean>("queryMemoryDataSync");
      jni::local_ref<jni::JBoolean> queryMemoryDataSync = this->getFieldValue(fieldQueryMemoryDataSync);
      static const auto fieldQueryDiskDataSync = clazz->getField<jni::JBoolean>("queryDiskDataSync");
      jni::local_ref<jni::JBoolean> queryDiskDataSync = this->getFieldValue(fieldQueryDiskDataSync);
      static const auto fieldDecodeImage = clazz->getField<jni::JBoolean>("decodeImage");
      jni::local_ref<jni::JBoolean> decodeImage = this->getFieldValue(fieldDecodeImage);
      return AsyncImageLoadOptions(
        priority != nullptr ? std::make_optional(priority->toCpp()) : std::nullopt,
        forceRefresh != nullptr ? std::make_optional(static_cast<bool>(forceRefresh->value())) : std::nullopt,
        continueInBackground != nullptr ? std::make_optional(static_cast<bool>(continueInBackground->value())) : std::nullopt,
        allowInvalidSSLCertificates != nullptr ? std::make_optional(static_cast<bool>(allowInvalidSSLCertificates->value())) : std::nullopt,
        scaleDownLargeImages != nullptr ? std::make_optional(static_cast<bool>(scaleDownLargeImages->value())) : std::nullopt,
        queryMemoryDataSync != nullptr ? std::make_optional(static_cast<bool>(queryMemoryDataSync->value())) : std::nullopt,
        queryDiskDataSync != nullptr ? std::make_optional(static_cast<bool>(queryDiskDataSync->value())) : std::nullopt,
        decodeImage != nullptr ? std::make_optional(static_cast<bool>(decodeImage->value())) : std::nullopt
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JAsyncImageLoadOptions::javaobject> fromCpp(const AsyncImageLoadOptions& value) {
      return newInstance(
        value.priority.has_value() ? JAsyncImagePriority::fromCpp(value.priority.value()) : nullptr,
        value.forceRefresh.has_value() ? jni::JBoolean::valueOf(value.forceRefresh.value()) : nullptr,
        value.continueInBackground.has_value() ? jni::JBoolean::valueOf(value.continueInBackground.value()) : nullptr,
        value.allowInvalidSSLCertificates.has_value() ? jni::JBoolean::valueOf(value.allowInvalidSSLCertificates.value()) : nullptr,
        value.scaleDownLargeImages.has_value() ? jni::JBoolean::valueOf(value.scaleDownLargeImages.value()) : nullptr,
        value.queryMemoryDataSync.has_value() ? jni::JBoolean::valueOf(value.queryMemoryDataSync.value()) : nullptr,
        value.queryDiskDataSync.has_value() ? jni::JBoolean::valueOf(value.queryDiskDataSync.value()) : nullptr,
        value.decodeImage.has_value() ? jni::JBoolean::valueOf(value.decodeImage.value()) : nullptr
      );
    }
  };

} // namespace margelo::nitro::image
